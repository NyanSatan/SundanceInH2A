#!/usr/bin/env python3

import os
import time
import json
import shutil
import zipfile
import tarfile
import tempfile
import argparse
import plistlib
import subprocess
from pathlib import Path
from typing import List
from dataclasses import dataclass, fields, is_dataclass

from yolosign import yolosign, off2page

# ===================== patch config =====================

def hexint(s: str):
    return int(s, 16)

def BytesOrString(s: str):
    try:
        return bytes.fromhex(s)
    except ValueError:
        return s.encode("ascii") + b"\0"

@dataclass
class Patch:
    name: str
    offset: hexint
    patch: BytesOrString

@dataclass
class FilePatch:
    path: str
    patches: List[Patch]

@dataclass
class CopyEmbeddedResource:
    embedded: str
    dest: str

@dataclass
class Bluetooth:
    filename: str
    offset: hexint
    length: hexint

@dataclass
class ManifestItem:
    component: str
    iv: str = None
    key: str = None
    patches: List[Patch] = None
    copy_files: List[str] = None
    launchdaemons_to_unlimit: List[str] = None
    file_patches: List[FilePatch] = None
    copy_embedded_files: List[CopyEmbeddedResource] = None
    bluetooth: Bluetooth = None

@dataclass
class IPSWConfig:
    device: str
    build: str
    manifest: List[ManifestItem]

    def component(self, comp: str):
        return next(filter(lambda x: x.component == comp, self.manifest))

@dataclass
class Config:
    source_ipsw: IPSWConfig
    base_ipsw: IPSWConfig
    defaults: dict

def dataclass_from_dict(cls, d):
    if isinstance(d, list):
        (inner,) = cls.__args__
        return [dataclass_from_dict(inner, i) for i in d]

    if is_dataclass(cls):
        fieldtypes = {f.name:f.type for f in fields(cls)}
        return cls(**{f:dataclass_from_dict(fieldtypes[f],d[f]) for f in d})
    else:
        return cls(d)

SUNDANCE_RAMDISK_SIZE = 16 * 1024 * 1024

# ===================== debug logging =====================

NONE   = ""
DIM    = "\u001b[2m"
RESET  = "\u001b[0m"

start_time = 0.0
_verbose = False

def _debug_init(verbose: bool):
    global start_time, _verbose
    start_time = time.time()   
    _verbose = verbose

def _log(color, args, kwargs):
    print(color + "|%7.3f |  " % (time.time() - start_time), end="")
    print(*args, **kwargs, end=RESET+"\n")

def log(*args, **kwargs):
    _log(NONE, args, kwargs)

def debug(*args, **kwargs):
    if _verbose:
        _log(DIM, args, kwargs)

# ================== subprocess wrappers ==================

def _run(exec: Path, args: List[str], env: dict = None):
    subprocess.run([exec] + args, env=env, check=True, stdout=subprocess.DEVNULL)

def image3_decrypt(src: Path, dest: Path, iv: str, key: str, keep_cont: bool = False):
    args = [str(src), str(dest), "-iv", str(iv), "-k", str(key)]

    if keep_cont:
        args += ["-decrypt"]

    _run(
        SCRIPT_ROOT / "executables" / "xpwntool",
        args
    )

    debug("decrypted Image3 at %s to %s" % (src.name, dest.name))

def image3_create(src: Path, dest: Path, template: Path):
    _run(
        SCRIPT_ROOT / "executables" / "xpwntool",
        [str(src), str(dest), "-t", str(template)]
    )

    debug("created Image3 at %s from %s with template %s" % (dest.name, src.name, template.name))

def dmg_extract(src: Path, dest: Path, key: str):
    _run(
        SCRIPT_ROOT / "executables" / "dmg",
        ["extract", str(src), str(dest), "-k", key]
    )

    debug("decrypted DMG at %s to %s" % (src.name, dest.name))

def dmg_build(src: Path, dest: Path):
    _run(
        SCRIPT_ROOT / "executables" / "dmg",
        ["build", str(src), str(dest)]
    )

    debug("built DMG at %s to %s" % (src.name, dest.name))

def hfsplus_grow(dmg: Path, size: int):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "grow", str(size)]
    )

    debug("grown HFS+ image at %s to %d bytes" % (dmg.name, size))

def hfsplus_extract(dmg: Path, src: str, dest: Path):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "extract", src, str(dest)]
    )

    debug("extracted %s to %s from HFS+ image at %s" % (src, dest.name, dmg.name))

def hfsplus_replace(dmg: Path, src: Path, dest: str, uid: int = 0, gid: int = 0, mode: int = 0o644):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "rm", dest]
    )

    hfsplus_add(dmg, src, dest, uid, gid, mode)

def hfsplus_add(dmg: Path, src: Path, dest: str, uid: int = 0, gid: int = 0, mode: int = 0o644):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "add", str(src), dest]
    )

    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "chown", "%d:%d" % (uid, gid), dest]
    )

    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "chmod", "%o" % (mode), dest]
    )

    debug("added %s in HFS+ image at %s to %s" % (src.name, dmg.name, dest))

def hfsplus_rm(dmg: Path, path: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "rm", path]
    )

    debug("removed %s from HFS+ image at %s" % (path, dmg.name))

def hfsplus_rmdir(dmg: Path, dir: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "rmall", dir]
    )

    debug("removed %s folder from HFS+ image at %s" % (dir, dmg.name))

def hfsplus_mv(dmg: Path, src: str, dest: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "mv", src, dest]
    )

    debug("moved %s to %s in HFS+ image at %s" % (src, dest, dmg.name))

def hfsplus_untar(dmg: Path, tar: Path, dest: str):
    _run(
        SCRIPT_ROOT / "executables" / "hfsplus",
        [str(dmg), "untar", str(tar), dest]
    )

    debug("untar'd %s to %s in HFS+ image at %s" % (tar.name, dest, dmg.name))

# ===================== IPSW parsing =====================

class BuildIdentity:
    def __init__(self, raw: dict, manifest: "BuildManifest"):
        self.raw = raw
        self.manifest = manifest
        self.chip_id = raw["ApChipID"]
        self.board_id = raw["ApBoardID"]
        self.device = raw["Info"]["DeviceClass"]
        self.restore_behavior = raw["Info"]["RestoreBehavior"]
        self.build_train = raw["Info"]["BuildTrain"]
        self.minimum_system_partition = raw["Info"]["MinimumSystemPartition"]
        self.components = { k:v["Info"]["Path"] for k,v in raw["Manifest"].items() }

        debug("loaded build identity for %s (%s)" % (self.device, self.restore_behavior))

class BuildManifest:
    def __init__(self, data: bytes):
        self.raw = plistlib.loads(data)
        self.version = self.raw["ProductVersion"]
        self.build = self.raw["ProductBuildVersion"]
        self.identities = list()

        for i in self.raw["BuildIdentities"]:
            self.identities.append(BuildIdentity(i, self))

        debug("loaded build manifest for iOS %s (%s)" % (self.version, self.build))

    def find_identity(self, device: str, behavior: str) -> BuildIdentity:
        return next(filter(
            lambda x: x.device == device and x.restore_behavior == behavior,
            self.identities)
        )

class IPSW:
    def __init__(self, path: Path):
        self.path = path
        self._zip = zipfile.ZipFile(path)

        raw_manifest = self.read_file("BuildManifest.plist")
        self.manifest = BuildManifest(raw_manifest)

        debug("loaded IPSW")

    def read_file(self, path: str) -> bytes:
        return self._zip.read(path)
    
    def extract_file(self, src: str, dest: str):
        with self._zip.open(src, "r") as zf:
            with open(dest, "wb") as f:
                shutil.copyfileobj(zf, f)

def extract_comp(comp: str, dest_dir: Path, ipsw: IPSW, build_identity: BuildIdentity) -> str:
    path = build_identity.components[comp]
    name = os.path.basename(path)
    ipsw.extract_file(path, dest_dir / name)

    debug("extracted component %s from IPSW at %s" % (comp, ipsw.path))

    return name

# ====================== main logic ======================

@dataclass
class AddFile:
    src: Path
    dest: str
    uid: int = 0
    gid: int = 0
    mode: int = 0o644

def hoodoo_extract_firmwares(wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> List[AddFile]:
    result = []

    log("extracting iOS 5 root filesystem")
    os_orig_path = wd / extract_comp("OS", wd, ipsw, build_identity)
    os_raw_path = os_orig_path.with_name("HoodooOS.dmg")

    os_cfg = gCfg.source_ipsw.component("OS")
    dmg_extract(os_orig_path, os_raw_path, os_cfg.key)
    os_orig_path.unlink()

    if os_cfg.copy_files:
        log("extracting WLAN & multitouch firmwares")

        for f in os_cfg.copy_files:
            hfsplus_extract(os_raw_path, f, wd / os.path.basename(f))
            result.append(AddFile(
                wd / os.path.basename(f),
                f
            ))

    if os_cfg.bluetooth:
        log("extracting Bluetooth firmware")

        bluetool_path = wd / "BlueTool"
        hfsplus_extract(os_raw_path, "/usr/sbin/BlueTool", bluetool_path)

        with open(bluetool_path, "rb") as f:
            f.seek(os_cfg.bluetooth.offset)
            bluetooth_fw = f.read(os_cfg.bluetooth.length)

        bluetool_path.unlink()

        bluetooth_fw_path = wd / os_cfg.bluetooth.filename
        with open(bluetooth_fw_path, "wb") as f:
            f.write(bluetooth_fw)

        result.append(AddFile(
            bluetooth_fw_path,
            "/private/etc/bluetool/" + os_cfg.bluetooth.filename
        ))

    os_raw_path.unlink()

    return result

def patch_binary(src: Path, dest: Path, patches: List[Patch], codesign: bool = False):
    try:
        shutil.copyfile(src, dest)
    except shutil.SameFileError:
        pass

    pages = []
    with open(dest, "r+b") as f:
        for p in patches:
            f.seek(p.offset)
            f.write(p.patch)

            if codesign:
                pages.append(off2page(p.offset))

    if codesign:
        yolosign(dest, pages)

def hoodoo_replace_comp(comp: str, iv: str, key: str, src: Path, wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> str:
    path = wd / extract_comp(comp, wd, ipsw, build_identity)

    decrypted_path = path.with_suffix(".decrypted")
    image3_decrypt(path, decrypted_path, iv, key, keep_cont=True)
    path.unlink()

    image3_create(src, wd / comp, decrypted_path)
    decrypted_path.unlink()

    return comp

def hoodoo_process_iboots(wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> List[str]:
    result = {}

    # LLB
    result["LLB"] = extract_comp("LLB", wd, ipsw, build_identity)

    # iBoot
    result["iBoot"] = extract_comp("iBoot", wd, ipsw, build_identity)
    
    def patch_image3(src: Path, dest: Path, iv: str, key: str, patches: List[Patch]):
        raw_path = src.with_suffix(".raw")
        image3_decrypt(src, raw_path, iv, key)

        patched_path = src.with_suffix(".patched")
        patch_binary(raw_path, patched_path, patches)
        raw_path.unlink()

        template_path = src.with_suffix(".template")
        shutil.copyfile(src, template_path)
        image3_create(patched_path, dest, template_path)
        patched_path.unlink()
        template_path.unlink()

    # iBSS
    ibss_name = extract_comp("iBSS", wd, ipsw, build_identity)
    ibss_cfg = gCfg.source_ipsw.component("iBSS")
    ibss_orig_path = wd / ibss_name
    patch_image3(ibss_orig_path, ibss_orig_path, ibss_cfg.iv, ibss_cfg.key, ibss_cfg.patches)
    result["iBSS"] = ibss_name

    # iBEC
    ibec_name = extract_comp("iBEC", wd, ipsw, build_identity)
    ibec_cfg = gCfg.source_ipsw.component("iBEC")
    ibec_orig_path = wd / ibec_name
    patch_image3(ibec_orig_path, ibec_orig_path, ibec_cfg.iv, ibec_cfg.key, ibec_cfg.patches)
    result["iBEC"] = ibec_name

    return result

def _unlimit_launch_daemon(wd: Path, dmg_path: Path, launch_daemon: str):
    log("unlimiting %s LaunchDaemon" % os.path.basename(launch_daemon))

    plist_tmp_path = wd / "launch_daemon.plist"
    hfsplus_extract(dmg_path, launch_daemon, plist_tmp_path)

    with open(plist_tmp_path, "rb") as f:
        plist = plistlib.load(f)
        del plist["LimitLoadToHardware"]

    with open(plist_tmp_path, "wb") as f:
        plistlib.dump(plist, f, fmt=plistlib.FMT_XML)

    hfsplus_replace(dmg_path, plist_tmp_path, launch_daemon)
    plist_tmp_path.unlink()

JAILBREAK_ROOTFS_MIBS = 128

def sundance_process_root_filesystem(wd: Path, ipsw: IPSW, build_identity: BuildIdentity, to_add: List[AddFile], jailbreak: bool = False) -> str:
    log("extracting iOS 6 root filesystem")

    os_orig_path = wd / extract_comp("OS", wd, ipsw, build_identity)
    os_raw_path = os_orig_path.with_name("SundanceOS.dmg")
    os_cfg = gCfg.base_ipsw.component("OS")

    dmg_extract(os_orig_path, os_raw_path, os_cfg.key)
    os_orig_path.unlink()

    log("removing OTA update files")
    hfsplus_rmdir(os_raw_path, "/usr/standalone/update")

    log("patching files")

    if os_cfg.file_patches:
        for p in os_cfg.file_patches:
            file_tmp_path = wd / "f"
            hfsplus_extract(os_raw_path, p.path, file_tmp_path)
            patch_binary(file_tmp_path, file_tmp_path, p.patches, codesign=True)
            hfsplus_replace(os_raw_path, file_tmp_path, p.path, mode=0o755)
            file_tmp_path.unlink()

    if os_cfg.launchdaemons_to_unlimit:
        for ld in os_cfg.launchdaemons_to_unlimit:
            _unlimit_launch_daemon(wd, os_raw_path, ld)

    if os_cfg.copy_embedded_files:
        for f in os_cfg.copy_embedded_files:
            to_add.append(AddFile(RESOURCES_ROOT / f.embedded, f.dest))

    # `hfsplus` messes up if we create already existing folders/files,
    # `hfsplus` messes up if add files to non-existing folders,
    # so we use tarball extraction capability that handles all that well
    tar_path = wd / "files.tar"
    tar = tarfile.open(tar_path, "x", format=tarfile.GNU_FORMAT)

    already_there = set()

    for a in to_add:
        p = ""

        # `hfsplus` needs explicit entries for directories
        comps = str(Path(a.dest).parent).split("/")
        for c in comps:
            if not c:
                continue

            p += c + "/"

            if p not in already_there:
                inf = tarfile.TarInfo(p)
                inf.type = tarfile.DIRTYPE
                inf.uid = 0
                inf.gid = 0
                inf.mode = 0o755

                tar.addfile(inf)

                already_there.add(p)

        inf = tarfile.TarInfo(a.dest[1:])
        inf.type = tarfile.REGTYPE
        inf.size = os.stat(a.src).st_size
        inf.uid = a.uid
        inf.gid = a.gid
        inf.mode = a.mode

        with open(a.src, "rb") as f:
            tar.addfile(inf, f)

        debug("added %s to temporary tarball" % a.dest)

    tar.close()
    hfsplus_untar(os_raw_path, tar_path, "/")
    tar_path.unlink()

    if jailbreak:
        log("growing root filesystem")
        hfsplus_grow(os_raw_path, (build_identity.minimum_system_partition + JAILBREAK_ROOTFS_MIBS) * 1024 * 1024)

        log("unpacking Cydia tarball")
        hfsplus_untar(os_raw_path, RESOURCES_ROOT / "Cydia.tar", "/")

        with tempfile.NamedTemporaryFile() as f:
            hfsplus_add(os_raw_path, Path(f.name), "/.cydia_no_stash")

        log("replacing fstab")
        hfsplus_replace(os_raw_path, RESOURCES_ROOT / "fstab", "/private/etc/fstab")

    # breaks everything, unfortunately
    # hfsplus_mv(os_raw_path, "/", "/%s%s.N18OS" % (build_identity.build_train, ipsw.manifest.build))

    log("packaging iOS 6 root filesystem")
    os_dest = "SundanceOSN18.dmg"
    dmg_build(os_raw_path, wd / os_dest)
    os_raw_path.unlink()

    return os_dest

def sundance_process_ramdisk(wd: Path, ipsw: IPSW, build_identity: BuildIdentity) -> str:
    log("extracting iOS 6 ramdisk")

    rd_orig_path = wd / extract_comp("RestoreRamDisk", wd, ipsw, build_identity)
    rd_raw_path = rd_orig_path.with_name("SundanceRamdisk.dmg")
    rd_cfg = gCfg.base_ipsw.component("RestoreRamDisk")

    image3_decrypt(rd_orig_path, rd_raw_path, rd_cfg.iv, rd_cfg.key)

    log("growing ramdisk")
    hfsplus_grow(rd_raw_path, SUNDANCE_RAMDISK_SIZE)

    if rd_cfg.file_patches:
        for p in rd_cfg.file_patches:
            file_tmp_path = wd / "f"
            hfsplus_extract(rd_raw_path, p.path, file_tmp_path)
            patch_binary(file_tmp_path, file_tmp_path, p.patches, codesign=True)
            hfsplus_replace(rd_raw_path, file_tmp_path, p.path, mode=0o755)
            file_tmp_path.unlink()

    log("replacing rc.boot")
    hfsplus_replace(rd_raw_path, SCRIPT_ROOT / "rc_boot" / "rc.boot", "/etc/rc.boot", mode=0o755)

    log("putting exploit.dmg")
    hfsplus_add(rd_raw_path, SCRIPT_ROOT / "exploit" / "exploit.dmg", "/exploit.dmg")

    log("moving options plist")
    hfsplus_mv(rd_raw_path, "/usr/local/share/restore/options.n88.plist", "/usr/local/share/restore/options.n18.plist")

    log("packaging iOS 6 ramdisk")
    rd_dest = "SundanceRamdiskPatched.img3"
    image3_create(rd_raw_path, wd / rd_dest, rd_orig_path)

    rd_orig_path.unlink()
    rd_raw_path.unlink()

    return rd_dest

def assemble_bundle(
    wd: Path,
    hoodoo_ipsw: IPSW,
    hoodoo_identity: BuildIdentity,
    sundance_ipsw: IPSW,
    sundance_identity: BuildIdentity,
    patched_comps: dict,
    output: Path
):
    log("assembling bundle")

    output.mkdir()

    raw_identity = hoodoo_identity.raw.copy()
    raw_identity["Info"]["BuildNumber"] = sundance_ipsw.manifest.build
    raw_identity["Info"]["BuildTrain"] = sundance_identity.build_train

    for k,v in raw_identity["Manifest"].items():
        comp_path = v["Info"]["Path"]
        comp_parent = os.path.dirname(comp_path)

        comp_parent_dest = output / comp_parent
        comp_parent_dest.mkdir(exist_ok=True, parents=True)

        comp_dest = comp_parent_dest / os.path.basename(comp_path)

        if k in patched_comps:
            if comp_dest.exists():
                comp_dest.unlink()
            shutil.copyfile(wd / patched_comps[k], comp_dest)
        else:
            hoodoo_ipsw.extract_file(comp_path, comp_dest)

    raw_manifest = hoodoo_ipsw.manifest.raw.copy()
    raw_manifest["ProductBuildVersion"] = sundance_ipsw.manifest.build
    raw_manifest["ProductVersion"] = sundance_ipsw.manifest.version
    raw_manifest["BuildIdentities"] = [raw_identity]

    with open(output / "BuildManifest.plist", "wb") as f:
        plistlib.dump(raw_manifest, f, fmt=plistlib.FMT_XML)
        log("wrote BuildManifest")

def process(args):
    global gCfg

    hoodoo_ipsw = IPSW(args.hoodoo)
    hoodoo_identity = hoodoo_ipsw.manifest.find_identity("n18ap", "Erase")

    sundance_ipsw = IPSW(args.sundance)
    sundance_identity = sundance_ipsw.manifest.find_identity("n88ap", "Erase")

    gCfg = _load_config(hoodoo_identity, sundance_identity)

    with tempfile.TemporaryDirectory() as wd:
        wd = Path(wd)

        patched_comps = {}

        log("processing iOS 5 iBoots")
        patched_comps.update(hoodoo_process_iboots(wd, hoodoo_ipsw, hoodoo_identity))

        log("packaging kernelcache")
        kc_cfg = gCfg.source_ipsw.component("KernelCache")
        patched_comps["KernelCache"] = patched_comps["RestoreKernelCache"] = hoodoo_replace_comp("KernelCache", kc_cfg.iv, kc_cfg.key, args.kernel, wd, hoodoo_ipsw, hoodoo_identity)

        log("packaging DeviceTree")
        dt_cfg = gCfg.source_ipsw.component("DeviceTree")
        patched_comps["DeviceTree"] = patched_comps["RestoreDeviceTree"] = hoodoo_replace_comp("DeviceTree", dt_cfg.iv, dt_cfg.key, args.devicetree, wd, hoodoo_ipsw, hoodoo_identity)

        add_files = []
        add_files += hoodoo_extract_firmwares(wd, hoodoo_ipsw, hoodoo_identity)

        patched_comps["OS"] = sundance_process_root_filesystem(wd, sundance_ipsw, sundance_identity, add_files, args.jailbreak)
        patched_comps["RestoreRamDisk"] = sundance_process_ramdisk(wd, sundance_ipsw, sundance_identity)

        assemble_bundle(
            wd,
            hoodoo_ipsw,
            hoodoo_identity,
            sundance_ipsw,
            sundance_identity,
            patched_comps,
            args.output
        )

def _load_config(source_identity: BuildIdentity, base_identity: BuildIdentity) -> Config:
    for root, dirs, files in os.walk(CONFIGS_ROOT):
        for f in files:
            full_path = Path(root) / f

            if full_path.suffix != ".json":
                continue

            with open(full_path, "r") as f:
                curr = json.load(f)

            if curr["source_ipsw"]["device"] == source_identity.device and curr["source_ipsw"]["build"] == source_identity.manifest.build \
                and curr["base_ipsw"]["device"] == base_identity.device and curr["base_ipsw"]["build"] == base_identity.manifest.build:
                return dataclass_from_dict(Config, curr)

SCRIPT_ROOT = Path(__file__).parent
RESOURCES_ROOT = SCRIPT_ROOT / "resources"
CONFIGS_ROOT = SCRIPT_ROOT / "configs"

DEFAULT_KERNEL = SCRIPT_ROOT / "artifacts" / "kernelcache.n18ap.bin"
DEFAULT_JAILBROKEN_KERNEL = SCRIPT_ROOT / "artifacts" / "kernelcache.jailbroken.n18ap.bin"
DEFAULT_DEVICE_TREE = SCRIPT_ROOT / "artifacts" / "DeviceTree.n18ap.bin"

gCfg = None

def main():
    parser = argparse.ArgumentParser(description="convert iPod touch 3 iOS 5.1.1 IPSW to iOS 6.0")
    parser.add_argument("hoodoo", type=Path, help="path to iPod touch 3 5.1.1 (9B206) IPSW")
    parser.add_argument("sundance", type=Path, help="path to iPhone 3GS 6.0 (10A403) IPSW")
    parser.add_argument("output", type=Path, help="output IPSW to flash")
    parser.add_argument("-j", "--jailbreak", action="store_true", help="apply jailbreak")
    parser.add_argument(
        "-k", "--kernel",
        type=Path,
        help="path to kernel, default - the one in artifacts/"
    )
    parser.add_argument(
        "-d", "--devicetree",
        type=Path,
        default=DEFAULT_DEVICE_TREE,
        help="path to DeviceTree, default - " + str(DEFAULT_DEVICE_TREE.relative_to(SCRIPT_ROOT))
    )
    parser.add_argument("-v", "--verbose", action="store_true", help="verbose logging")

    args = parser.parse_args()

    if not args.kernel:
        if args.jailbreak:
            args.kernel = DEFAULT_JAILBROKEN_KERNEL
        else:
            args.kernel = DEFAULT_KERNEL

    _debug_init(args.verbose)

    if not args.hoodoo.exists():
        print("iPod touch 3 5.1.1 (9B206) IPSW does NOT exist")
        exit(-1)

    if not args.sundance.exists():
        print("iPhone 3GS 6.0 (10A403) IPSW does NOT exist")
        exit(-1)

    if not args.kernel.exists():
        print("kernelcache does NOT exist")
        exit(-1)

    if args.output.exists():
        print("output path already exists")
        exit(-1)

    process(args)

    log("DONE!")

if __name__ == "__main__":
    main()
